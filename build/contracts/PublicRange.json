{
  "contractName": "PublicRange",
  "abi": [
    {
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "fallback"
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.5.4+commit.9549d8ff\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}],\"devdoc\":{\"author\":\"AZTEC\",\"details\":\"Library to validate AZTEC public range zero-knowledge proofs Don't include this as an internal library. This contract uses  a static memory table to cache elliptic curve primitives and hashes. Calling this internally from another function will lead to memory  mutation and undefined behaviour. The intended use case is to call this externally via `staticcall`. External  calls to OptimizedAZTEC can be treated as pure functions as this contract  contains no storage and makes no external calls (other than to precompiles) Copyright Spilsbury Holdings Ltd 2019. All rights reserved.*\",\"methods\":{},\"title\":\"PublicRange\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"@aztec/protocol/contracts/ACE/validators/publicRange/PublicRange.sol\":\"PublicRange\"},\"evmVersion\":\"constantinople\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":500},\"remappings\":[]},\"sources\":{\"@aztec/protocol/contracts/ACE/validators/publicRange/PublicRange.sol\":{\"keccak256\":\"0xf8b23745d9005b17c4779ec7d9b1e7eb6f3e493a88e2d81fa9add4526f4ff7fc\",\"urls\":[\"bzzr://e85987a3508a2fa9fadadf219f0cdfa715483daa8e23a6bb64adbf41ea0605d4\"]},\"@aztec/protocol/contracts/ACE/validators/publicRange/PublicRangeABIEncoder.sol\":{\"keccak256\":\"0xa44ddf8578aa10983624240cdc9463ebc4b86f4220cce51be75690103388f60a\",\"urls\":[\"bzzr://33ec82c40ac3b1fdff38b5d54d3a3d66c1cd138ad79385c22b590cc52e5add4a\"]},\"@aztec/protocol/contracts/interfaces/PublicRangeInterface.sol\":{\"keccak256\":\"0x202c5aba94c168f86bf0eeb52f867c3af74f19ce932a03191071b8a9d73da072\",\"urls\":[\"bzzr://bafd73d739101db27d76fa137509ffb5ccc01dd7de332d592ef7b59d2bb2aa34\"]}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610764806100206000396000f3fe608060405234801561001057600080fd5b50610019610023565b6060604052610200565b60443560805260643560a0526101643561010401600260017f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061012435068161014435066024356102e052806103005260006103205260006103405261008a8587610485565b608085026103600160005b868110156101cb5760c081026020890101600060208201358660008511600181146100c55780156100d9576100de565b898a89848d030960c08703350893506100de565b843593505b506100ea828486610205565b600085111561010c57886000510689818509935089818409925089818a099150505b60406080850160e037604080850160203780890361012052826060528160c05260406101a0606060e060075afa60406101206060602060075afa1660406101606060608060075afa166040610160608061012060065afa16604087608061016060065afa811690508160605260406102206060602060075afa166040610260608061022060065afa1660406101e060806101a060065afa168015156101b75761019060005260206000fd5b505050604093909301925050600101610095565b506101d660846102b4565b6102df1981016102e0208490068381146101f65761019460005260206000fd5b5050505050505050565b6102af565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760408301356060840135608085013560a086013584838409856003878789898a090908148582830986600388868a888909090814166001891189888b06141660018b118b898d061416161615156102a45761019060005260206000fd5b505050505050505050565b610480565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4781356020830135604084013560608501357f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81147f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa83147f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c285147f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed87148415861588158a1517171717171717156103925761019060005260206000fd5b6101e051602052610200516040527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6080527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26060527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60c0527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b60a0526102605160e05261028051610100528361014052826101205281610180528061016052602080610180602060085afa60205115811517156104775761019060005260206000fd5b50505050505050565b6104bc565b60005b828110156104ae57606060c0820283010160808160808402610360013750600101610488565b505060800261036020600052565b6104c46104c6565b005b61016435610104016002600161018435610124016101a435610124016101c4356101440160016101a05260606101c05260c06102005260006102405260006102605261012435610280526102a0846020820152602085026102e00160005b868110156105ef5760c0810260208a0101600160005260806040820160203760c08352600160208401528635604084015260a06000206060840152604060808401527f800000000000000000000000000000000000000000000000000000000000000060016060830135160260408201351760a08401527f8000000000000000000000000000000000000000000000000000000000000000600160a0830135160260808201351760c08401528383036020830260408601015260e08301925050600181019050610524565b50601f1982820390810190925260c0909101610220528486036020828101829052028101604001855b878110156107095760c0810260208a01016020888303028501358060408703013560016000526080604084016020378060c00185526001602086015260208a850302880135604086015260a060002060608601528060400160808601527f8000000000000000000000000000000000000000000000000000000000000000600160405116026020511760a08601527f8000000000000000000000000000000000000000000000000000000000000000600160805116026060511760c08601528060208803830160e087013785850360208b860302604088010152602085510185019450505050600181019050610618565b5060208282030382526102a081038060a0016101e0528061010001610180526020610160528061014001610160f3fea165627a7a72305820fd345680ec5d2b532b849421d3022a5d60e58c2ba2fe83d3fafc1a8888d47f8a0029",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50610019610023565b6060604052610200565b60443560805260643560a0526101643561010401600260017f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018061012435068161014435066024356102e052806103005260006103205260006103405261008a8587610485565b608085026103600160005b868110156101cb5760c081026020890101600060208201358660008511600181146100c55780156100d9576100de565b898a89848d030960c08703350893506100de565b843593505b506100ea828486610205565b600085111561010c57886000510689818509935089818409925089818a099150505b60406080850160e037604080850160203780890361012052826060528160c05260406101a0606060e060075afa60406101206060602060075afa1660406101606060608060075afa166040610160608061012060065afa16604087608061016060065afa811690508160605260406102206060602060075afa166040610260608061022060065afa1660406101e060806101a060065afa168015156101b75761019060005260206000fd5b505050604093909301925050600101610095565b506101d660846102b4565b6102df1981016102e0208490068381146101f65761019460005260206000fd5b5050505050505050565b6102af565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000017f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760408301356060840135608085013560a086013584838409856003878789898a090908148582830986600388868a888909090814166001891189888b06141660018b118b898d061416161615156102a45761019060005260206000fd5b505050505050505050565b610480565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4781356020830135604084013560608501357f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81147f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa83147f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c285147f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed87148415861588158a1517171717171717156103925761019060005260206000fd5b6101e051602052610200516040527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6080527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26060527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60c0527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b60a0526102605160e05261028051610100528361014052826101205281610180528061016052602080610180602060085afa60205115811517156104775761019060005260206000fd5b50505050505050565b6104bc565b60005b828110156104ae57606060c0820283010160808160808402610360013750600101610488565b505060800261036020600052565b6104c46104c6565b005b61016435610104016002600161018435610124016101a435610124016101c4356101440160016101a05260606101c05260c06102005260006102405260006102605261012435610280526102a0846020820152602085026102e00160005b868110156105ef5760c0810260208a0101600160005260806040820160203760c08352600160208401528635604084015260a06000206060840152604060808401527f800000000000000000000000000000000000000000000000000000000000000060016060830135160260408201351760a08401527f8000000000000000000000000000000000000000000000000000000000000000600160a0830135160260808201351760c08401528383036020830260408601015260e08301925050600181019050610524565b50601f1982820390810190925260c0909101610220528486036020828101829052028101604001855b878110156107095760c0810260208a01016020888303028501358060408703013560016000526080604084016020378060c00185526001602086015260208a850302880135604086015260a060002060608601528060400160808601527f8000000000000000000000000000000000000000000000000000000000000000600160405116026020511760a08601527f8000000000000000000000000000000000000000000000000000000000000000600160805116026060511760c08601528060208803830160e087013785850360208b860302604088010152602085510185019450505050600181019050610618565b5060208282030382526102a081038060a0016101e0528061010001610180526020610160528061014001610160f3fea165627a7a72305820fd345680ec5d2b532b849421d3022a5d60e58c2ba2fe83d3fafc1a8888d47f8a0029",
  "sourceMap": "789:17125:14:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;789:17125:14;;;;;;;",
  "deployedSourceMap": "789:17125:14:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;789:17125:14;1576:21;;;;1865:4;1859;1852:18;4301:7163;;;4530:4;4517:18;4511:4;4504:32;4586:4;4573:18;4567:4;4560:32;4653:5;4640:19;4633:5;4629:31;4713:1;4740;4775:66;4900:9;4892:5;4879:19;4875:35;4976:9;4968:5;4955:19;4951:35;5031:4;5018:18;5011:5;5004:33;5112:16;5105:5;5098:31;5161:1;5154:5;5147:16;5225:1;5218:5;5211:16;5275:25;5298:1;5291:5;5275:25;;;5344:4;5341:1;5337:12;5330:5;5326:24;5654:1;5639:4819;5664:1;5661;5658:8;5639:4819;;;5842:4;5839:1;5835:12;5828:4;5821:5;5817:16;5813:35;;5932:4;5921:9;5917:20;5904:34;5968:9;6012:1;6009;6006:8;6040:1;6035:418;;;;6500:84;;;;5999:585;;6035:418;6396:9;6355;6337:16;6333:1;6322:9;6318:17;6311:54;6268:4;6257:9;6253:20;6240:34;6204:227;6199:232;;6035:418;;6500:84;6551:9;6538:23;6533:28;;5999:585;;6666:35;6699:1;6696;6685:9;6666:35;;;6732:1;6729;6726:8;6723:2;;;6868:9;6861:4;6855:11;6851:27;6969:9;6966:1;6963;6956:23;6951:28;;7028:9;7025:1;7022;7015:23;7010:28;;7095:9;7092:1;7081:9;7074:31;7069:36;;6735:398;6723:2;8010:4;8003;7992:9;7988:20;7982:4;7969:46;8077:4;8070;8059:9;8055:20;8049:4;8036:46;8132:1;8121:9;8117:17;8110:5;8103:32;8170:1;8164:4;8157:15;8206:1;8200:4;8193:15;8612:4;8605:5;8599:4;8593;8590:1;8585:3;8574:43;8711:4;8704:5;8698:4;8692;8689:1;8684:3;8673:43;8661:56;8798:4;8791:5;8785:4;8779;8776:1;8771:3;8760:43;8748:56;9085:4;9078:5;9072:4;9065:5;9062:1;9057:3;9046:44;9034:57;9320:4;9317:1;9311:4;9304:5;9301:1;9296:3;9285:40;9277:6;9273:53;9263:63;;9762:1;9756:4;9749:15;9845:4;9838:5;9832:4;9826;9823:1;9818:3;9807:43;9795:56;10022:4;10015:5;10009:4;10002:5;9999:1;9994:3;9983:44;9971:57;10197:4;10190:5;10184:4;10177:5;10174:1;10169:3;10158:44;10146:57;10314:14;;10311:2;;;10344:3;10338:4;10331:17;10362:4;10356;10349:18;10311:2;-1:-1:-1;;;10402:4:14;10395:12;;;;;-1:-1:-1;;5681:4:14;5674:12;5639:4819;;;5643:14;10708:21;10724:4;10708:21;;;-1:-1:-1;;11225:13:14;;11232:5;11208:31;11204:47;;;11279:23;;;11269:2;;11389:3;11383:4;11376:17;11427:4;11421;11414:18;11269:2;4332:7132;;;;;;;;;;11803:2065;;;11878:66;11980;12100:4;12094;12090:15;12077:29;12160:4;12154;12150:15;12137:29;12220:4;12214;12210:15;12197:29;12280:4;12274;12270:15;12257:29;13649:11;13641:6;13633;13626:35;13580:11;13577:1;13526:11;13481:6;13430:11;13422:6;13414;13407:35;13363:175;13356:236;13302:389;13230:11;13222:6;13214;13207:35;13161:11;13121:1;13070:11;13062:6;13048:11;13040:6;13032;13025:35;12981:101;12974:199;12920:352;12887:830;12768:1;12765;12762:8;12694:1;12682:9;12679:1;12675:17;12672:24;12635:200;12529:1;12526;12523:8;12455:1;12443:9;12440:1;12436:17;12433:24;12396:209;12363:498;12334:1405;12306:1451;12303:2;;;13793:3;13787:4;13780:17;13831:4;13825;13818:18;12303:2;11843:2025;;;;;;;;;;;14103:2490;;;14169:66;14279:2;14266:16;14334:4;14330:2;14326:13;14313:27;14392:4;14388:2;14384:13;14371:27;14450:4;14446:2;14442:13;14429:27;15045:65;15037:6;15034:77;14944:66;14936:6;14933:78;14843:66;14835:6;14832:78;14742:66;14734:6;14731:78;14701:6;14694:14;14664:6;14657:14;14627:6;14620:14;14591:6;14584:14;14560:75;14557:115;14554:155;14551:259;14548:363;14545:467;14542:570;14539:2;;;15164:3;15158:4;15151:17;15202:4;15196;15189:18;14539:2;15577:5;15571:12;15565:4;15558:26;15643:5;15637:12;15631:4;15624:26;15703:66;15697:4;15690:80;15800:66;15794:4;15787:80;15897:66;15891:4;15884:80;15994:65;15988:4;15981:79;16096:5;16090:12;16084:4;16077:26;16163:5;16157:12;16150:5;16143:27;16224:6;16217:5;16210:21;16262:6;16255:5;16248:21;16300:6;16293:5;16286:21;16338:6;16331:5;16324:21;16416:4;16410;16403:5;16397:4;16394:1;16389:3;16378:43;16475:4;16469:11;16462:19;16452:7;16445:15;16442:40;16439:2;;;16518:3;16512:4;16505:17;16556:4;16550;16543:18;16439:2;14132:2461;;;;;;;;;17203:475;;;17271:1;17256:202;17281:1;17278;17275:8;17256:202;;;17367:4;17359;17356:1;17352:12;17345:5;17341:24;17337:35;17435:4;17428:5;17420:4;17417:1;17413:12;17406:5;17402:24;17389:51;-1:-1:-1;17298:4:14;17291:12;17256:202;;;-1:-1:-1;;17657:4:14;17650:12;17643:5;17633:30;17627:4;17620:44;17238:440;;17868:37;:35;:37::i;:::-;789:17125;1479:8980:15;1628:5;1615:19;1608:5;1604:31;1657:1;1680;1737:5;1724:19;1717:5;1713:31;1837:5;1824:19;1817:5;1813:31;1934:5;1921:19;1914:5;1910:31;3908:4;3901:5;3894:19;3987:4;3980:5;3973:19;4121:4;4114:5;4107:19;4260:4;4253:5;4246:19;4320:1;4313:5;4306:16;4432:5;4419:19;4412:5;4405:34;4469:5;4570:1;4563:4;4553:8;4549:19;4542:30;4739:4;4736:1;4732:12;4725:5;4721:24;4774:1;4759:2108;4784:1;4781;4778:8;4759:2108;;;4873:4;4870:1;4866:12;4859:4;4852:5;4848:16;4844:35;4958:4;4952;4945:18;5048:4;5041;5030:9;5026:20;5020:4;5007:46;5146:4;5143:1;5136:15;5247:4;5240;5237:1;5233:12;5226:26;5353:11;5340:25;5333:4;5330:1;5326:12;5319:47;5482:4;5476;5466:21;5459:4;5456:1;5452:12;5445:43;5610:4;5603;5600:1;5596:12;5589:26;5962:66;5927:4;5919;5908:9;5904:20;5891:34;5887:45;5854:200;5822:4;5811:9;5807:20;5794:34;5766:310;5739:4;5736:1;5732:12;5704:390;6441:66;6406:4;6398;6387:9;6383:20;6370:34;6366:45;6333:200;6301:4;6290:9;6286:20;6273:34;6245:310;6218:4;6215:1;6211:12;6183:390;6728:8;6725:1;6721:16;6713:4;6710:1;6706:12;6699:4;6689:8;6685:19;6681:38;6674:64;6848:4;6845:1;6841:12;6836:17;;4809:2058;4801:4;4798:1;4794:12;4789:17;;4759:2108;;;-1:-1:-1;;;6980:16:15;;;6976:27;;;6959:45;;;7035:4;7031:27;;;7024:5;7017:42;7173:9;;;6998:4;7152:19;;;7145:38;;;7250:20;7233:39;;7244:4;7233:39;7180:1;7314:2474;7339:1;7336;7333:8;7314:2474;;;7462:4;7459:1;7455:12;7448:4;7441:5;7437:16;7433:35;7591:4;7587:1;7584;7580:9;7576:20;7566:8;7562:35;7549:49;7715:13;7708:4;7698:8;7694:19;7690:39;7677:53;7761:4;7755;7748:18;7900:4;7893;7882:9;7878:20;7872:4;7859:46;8007:14;8001:4;7997:25;7994:1;7987:36;8119:4;8112;8109:1;8105:12;8098:26;8269:4;8265:1;8262;8258:9;8254:20;8240:12;8236:39;8223:53;8216:4;8213:1;8209:12;8202:75;8366:4;8360;8350:21;8343:4;8340:1;8336:12;8329:43;8480:14;8474:4;8470:25;8463:4;8460:1;8456:12;8449:47;8797:66;8762:4;8755;8749:11;8745:22;8712:177;8681:4;8675:11;8647:264;8620:4;8617:1;8613:12;8585:344;9206:66;9175:4;9168;9162:11;9158:22;9129:165;9102:4;9096:11;9072:240;9049:4;9046:1;9042:12;9018:312;9464:14;9456:4;9446:8;9442:19;9427:13;9423:39;9416:4;9413:1;9409:12;9396:83;9642:8;9639:1;9635:16;9627:4;9623:1;9620;9616:9;9612:20;9605:4;9595:8;9591:19;9587:46;9580:72;9768:4;9764:1;9758:8;9754:19;9751:1;9747:27;9742:32;;7364:2424;;;7356:4;7353:1;7349:12;7344:17;;7314:2474;;;7318:14;9910:4;9899:8;9896:1;9892:16;9888:27;9878:8;9871:45;10010:5;10007:1;10003:13;10223:11;10217:4;10213:22;10206:5;10199:37;10274:11;10267:5;10263:23;10256:5;10249:38;10356:4;10349:5;10342:19;10399:11;10392:5;10388:23;10381:5;10374:38",
  "source": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./PublicRangeABIEncoder.sol\";\nimport \"../../../interfaces/PublicRangeInterface.sol\";\n\n/**\n * @title PublicRange\n * @author AZTEC\n * @dev Library to validate AZTEC public range zero-knowledge proofs\n * Don't include this as an internal library. This contract uses \n * a static memory table to cache elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory \n * mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`. External \n * calls to OptimizedAZTEC can be treated as pure functions as this contract \n * contains no storage and makes no external calls (other than to precompiles)\n * Copyright Spilsbury Holdings Ltd 2019. All rights reserved.\n **/\ncontract PublicRange {\n\n    /**\n     * @dev PublicRange.sol will take any transaction sent to it and attempt to validate a zero knowledge proof.\n     * If the proof is not valid, the transaction throws.\n     * @notice See PublicRangeInterface for how method calls should be constructed.\n     * PublicRange.sol is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    // solhint-disable payable-fallback\n    function() external {\n        assembly {\n\n            // We don't check for function signatures, there's only one function that \n            // ever gets called: validatePublicRange()\n            // We still assume calldata is offset by 4 bytes so that we can represent \n            // this contract through a compatible ABI\n            validatePublicRange()\n\n            // if we get to here, the proof is valid. We now 'fall through' the assembly block\n            // and into PublicRange.validatePublicRange()\n            // reset the free memory pointer because we're touching Solidity code again\n            mstore(0x40, 0x60)\n            /**\n             * New calldata map\n             * 0x04:0x24      = calldata location of proofData byte array \n             * 0x24:0x44      = message sender // sender\n             * 0x44:0x64      = h_x     // crs\n             * 0x64:0x84      = h_y     // crs\n             * 0x84:0xa4      = t2_x0   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xc4:0xe4      = t2_y0   // crs\n             * 0xe4:0x104     = t2_y1   // crs\n             * 0x104:0x124    = length of proofData byte array \n             * 0x124:0x144    = challenge\n             * 0x144:0x164    = publicComparison\n             * 0x164:0x184    = offset in byte array to notes\n             * 0x184:0x1a4    = offset in byte array to inputOwners\n             * 0x1a4:0x1c4    = offset in byte array to outputOwners\n             * 0x1c4:0x1e4    = offset in byte array to metadata\n             *\n             *\n             * Note data map (uint[6]) is\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n             * 0x40:0x80       = G1 element \\gamma_i\n             * 0x80:0xc0       = G1 element \\sigma_i\n             *\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an \n             * external contract then terrible things will happen!\n             *\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n             * 0x80:0xc0       = x-coordinate of generator h\n             * 0xc0:0xe0       = y-coordinate of generator h\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} \n             *                   concatenated with (B_i)_{i=0}^{n-1}\n             **/\n            function validatePublicRange() {\n                /*\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n                */\n\n                mstore(0x80, calldataload(0x44)) // h_x\n                mstore(0xa0, calldataload(0x64)) // h_y\n                let notes := add(0x104, calldataload(0x164)) // start position of notes\n                let n := 2\n                let m := 1\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let challenge := mod(calldataload(0x124), gen_order)\n                let publicComparison := mod(calldataload(0x144), gen_order)\n\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\n                mstore(0x300, publicComparison) \n                mstore(0x320, 0) // add kPublic = 0 to the hash\n                mstore(0x340, 0) // add publicOwner to the hash\n                hashCommitments(notes, n)\n                let b := add(0x360, mul(n, 0x80))\n\n                /*\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n                */\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                    // Get the calldata index of this note and associated parameters\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n                    let k\n                    let a := calldataload(add(noteIndex, 0x20))\n                    let c := challenge\n\n                    switch gt(i, 0)\n                    case 1 {\n                        /*\n                        Enforce the condition k_2 = k_1 - c*publicComparison\n                        */\n                        k := addmod(\n                            calldataload(sub(noteIndex, 0xc0)), // k_1\n                            mulmod(sub(gen_order, c), publicComparison, gen_order), \n                            gen_order\n                        )\n                    } \n                        \n                    case 0 {\n                        k := calldataload(noteIndex)\n\n                    }\n\n                    // Check this commitment is well formed\n                    validateCommitment(noteIndex, k, a)\n\n                    if gt(i, 0) {\n                        // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n                        let x := mod(mload(0x00), gen_order) // x is the kecca hash of the input commitments\n                        k := mulmod(k, x, gen_order) // kx\n                        a := mulmod(a, x, gen_order) // ax\n                        c := mulmod(challenge, x, gen_order) // cx\n                    }\n                    \n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n                    // Memory map:\n                    // 0x20: \\gamma_iX\n                    // 0x40: \\gamma_iY\n                    // 0x60: k_i\n                    // 0x80: hX\n                    // 0xa0: hY\n                    // 0xc0: a_i\n                    // 0xe0: \\sigma_iX\n                    // 0x100: \\sigma_iY\n                    // 0x120: -c\n\n\n                    // * Note data map (uint[6]) is\n                    // * 0x00:0x20       = Z_p element \\bar{k}_i\n                    // * 0x20:0x40       = Z_p element \\bar{a}_i\n                    // * 0x40:0x80       = G1 element \\gamma_i\n                    // * 0x80:0xc0       = G1 element \\sigma_i\n\n                    // loading into memory\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                    mstore(0x120, sub(gen_order, c)) \n                    mstore(0x60, k)\n                    mstore(0xc0, a)\n\n                    // Call bn128 scalar multiplication precompiles\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n                    // Store \\gamma_i^{k} at 0x120:0x160\n                    // Store h^{a} at 0x160:0x1a0\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40) // sigmai^-c\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n                    // Call bn128 group addition precompiles\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                    // Store result of addition at 0x160:0x1a0\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                    // Store resulting point B at memory index b\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n                    // Perform the pairing check for all notes - we do this by rolling all note coordinates into the\n                    // accumulator, upon which the pairing check is performed. \n                    // We do this adding \\sigma^{-c} and \\sigma_{acc} and storing the result at \n                    // \\sigma_{acc} (0x1e0:0x200). We then calculate \\gamma^{cx} and add into \\gamma_{acc}\n                    mstore(0x60, c)\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n\n                    // throw transaction if any calls to precompiled contracts failed\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n\n                    // Can assume by induction that k_1 is the output of a previous AZTEC transaction, and therefore \n                    // it already satisfies a range proof. Only need to perform an explicit range check on k2\n                    validatePairing(0x84)\n            \n                /*\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\n                */\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n                // starting at 0x2e0, of size (b - 0x2e0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n\n                if iszero(eq(expected, challenge)) {\n\n                    // No! Bad! No soup for you!\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\n             * throws if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                            and(\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n                                gt(a, 1)                  // can't be 0 or 1 either!\n                            ),\n                            and(\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n                                gt(k, 1)                  // and not 0 or 1\n                            )\n                        ),\n                        and(\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n                                    3, \n                                    field_order),\n                                mulmod(sigmaY, sigmaY, field_order)\n                            ),\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(gammaX, gammaX, field_order), \n                                    gammaX, \n                                    field_order), \n                                    3, field_order),\n                                mulmod(gammaY, gammaY, field_order)\n                            )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**        \n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\n             **/\n            function validatePairing(t2) {\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let t2_x_1 := calldataload(t2)\n                let t2_x_2 := calldataload(add(t2, 0x20))\n                let t2_y_1 := calldataload(add(t2, 0x40))\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n                // check provided setup pubkey is not zero or g2\n                if or(or(or(or(or(or(or(\n                    iszero(t2_x_1),\n                    iszero(t2_x_2)),\n                    iszero(t2_y_1)),\n                    iszero(t2_y_2)),\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n                {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // store coords in memory\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n                // to what precompile expects. We can overwrite the memory we used previously as this function\n                // is called at the end of the validation routine.\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n                mstore(0x140, t2_x_1)\n                mstore(0x120, t2_x_2)\n                mstore(0x180, t2_y_1)\n                mstore(0x160, t2_y_2)\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n                if or(iszero(success), iszero(mload(0x20))) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both \n             * input notes and output notes. This is used both as an input to \n             * validate the challenge `c` and also to generate pseudorandom relationships\n             * between commitments for different outputNotes, so that we can combine \n             * them into a single multi-exponentiation for the purposes of validating \n             * the bilinear pairing relationships.\n             * @param notes calldata location notes\n             * @param n number of notes\n             **/\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n                calldatacopy(add(0x360, mul(i, 0x80)), index, 0x80)\n                }\n                // storing at position 0x00 in memory, the kecca hash of everything from \n                // start of the commitments to the end\n                mstore(0x00, keccak256(0x360, mul(n, 0x80)))\n            }\n        }\n        // if we've reached here, we've validated the public range proof and haven't thrown an error.\n        // Encode the output according to the ACE standard and exit.\n        PublicRangeABIEncoder.encodeAndExit();\n    }\n}\n",
  "sourcePath": "@aztec/protocol/contracts/ACE/validators/publicRange/PublicRange.sol",
  "ast": {
    "absolutePath": "@aztec/protocol/contracts/ACE/validators/publicRange/PublicRange.sol",
    "exportedSymbols": {
      "PublicRange": [
        1730
      ]
    },
    "id": 1731,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1717,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:14"
      },
      {
        "absolutePath": "@aztec/protocol/contracts/ACE/validators/publicRange/PublicRangeABIEncoder.sol",
        "file": "./PublicRangeABIEncoder.sol",
        "id": 1718,
        "nodeType": "ImportDirective",
        "scope": 1731,
        "sourceUnit": 1739,
        "src": "33:37:14",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "@aztec/protocol/contracts/interfaces/PublicRangeInterface.sol",
        "file": "../../../interfaces/PublicRangeInterface.sol",
        "id": 1719,
        "nodeType": "ImportDirective",
        "scope": 1731,
        "sourceUnit": 3225,
        "src": "71:54:14",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title PublicRange\n@author AZTEC\n@dev Library to validate AZTEC public range zero-knowledge proofs\nDon't include this as an internal library. This contract uses \na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory \nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External \ncalls to OptimizedAZTEC can be treated as pure functions as this contract \ncontains no storage and makes no external calls (other than to precompiles)\nCopyright Spilsbury Holdings Ltd 2019. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1730,
        "linearizedBaseContracts": [
          1730
        ],
        "name": "PublicRange",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1728,
              "nodeType": "Block",
              "src": "1259:16653:14",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1722,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validatePublicRange()\n    mstore(0x40, 0x60)\n    function validatePublicRange()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x164))\n        let n := 2\n        let m := 1\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        let publicComparison := mod(calldataload(0x144), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        mstore(0x300, publicComparison)\n        mstore(0x320, 0)\n        mstore(0x340, 0)\n        hashCommitments(notes, n)\n        let b := add(0x360, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 0)\n            case 1 {\n                k := addmod(calldataload(sub(noteIndex, 0xc0)), mulmod(sub(gen_order, c), publicComparison, gen_order), gen_order)\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            if gt(i, 0)\n            {\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            mstore(0x60, c)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x360, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x360, mul(n, 0x80)))\n    }\n}",
                  "src": "1269:16620:14"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1723,
                        "name": "PublicRangeABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1738,
                        "src": "17868:21:14",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_PublicRangeABIEncoder_$1738_$",
                          "typeString": "type(library PublicRangeABIEncoder)"
                        }
                      },
                      "id": 1725,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1737,
                      "src": "17868:35:14",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1726,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "17868:37:14",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1727,
                  "nodeType": "ExpressionStatement",
                  "src": "17868:37:14"
                }
              ]
            },
            "documentation": "@dev PublicRange.sol will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction throws.\n@notice See PublicRangeInterface for how method calls should be constructed.\nPublicRange.sol is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1729,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1720,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1247:2:14"
            },
            "returnParameters": {
              "id": 1721,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1259:0:14"
            },
            "scope": 1730,
            "src": "1239:16673:14",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1731,
        "src": "789:17125:14"
      }
    ],
    "src": "0:17915:14"
  },
  "legacyAST": {
    "absolutePath": "@aztec/protocol/contracts/ACE/validators/publicRange/PublicRange.sol",
    "exportedSymbols": {
      "PublicRange": [
        1730
      ]
    },
    "id": 1731,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1717,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:14"
      },
      {
        "absolutePath": "@aztec/protocol/contracts/ACE/validators/publicRange/PublicRangeABIEncoder.sol",
        "file": "./PublicRangeABIEncoder.sol",
        "id": 1718,
        "nodeType": "ImportDirective",
        "scope": 1731,
        "sourceUnit": 1739,
        "src": "33:37:14",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "@aztec/protocol/contracts/interfaces/PublicRangeInterface.sol",
        "file": "../../../interfaces/PublicRangeInterface.sol",
        "id": 1719,
        "nodeType": "ImportDirective",
        "scope": 1731,
        "sourceUnit": 3225,
        "src": "71:54:14",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title PublicRange\n@author AZTEC\n@dev Library to validate AZTEC public range zero-knowledge proofs\nDon't include this as an internal library. This contract uses \na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory \nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External \ncalls to OptimizedAZTEC can be treated as pure functions as this contract \ncontains no storage and makes no external calls (other than to precompiles)\nCopyright Spilsbury Holdings Ltd 2019. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1730,
        "linearizedBaseContracts": [
          1730
        ],
        "name": "PublicRange",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1728,
              "nodeType": "Block",
              "src": "1259:16653:14",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1722,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validatePublicRange()\n    mstore(0x40, 0x60)\n    function validatePublicRange()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x164))\n        let n := 2\n        let m := 1\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        let publicComparison := mod(calldataload(0x144), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        mstore(0x300, publicComparison)\n        mstore(0x320, 0)\n        mstore(0x340, 0)\n        hashCommitments(notes, n)\n        let b := add(0x360, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 0)\n            case 1 {\n                k := addmod(calldataload(sub(noteIndex, 0xc0)), mulmod(sub(gen_order, c), publicComparison, gen_order), gen_order)\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            if gt(i, 0)\n            {\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            mstore(0x60, c)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x360, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x360, mul(n, 0x80)))\n    }\n}",
                  "src": "1269:16620:14"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1723,
                        "name": "PublicRangeABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1738,
                        "src": "17868:21:14",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_PublicRangeABIEncoder_$1738_$",
                          "typeString": "type(library PublicRangeABIEncoder)"
                        }
                      },
                      "id": 1725,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1737,
                      "src": "17868:35:14",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1726,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "17868:37:14",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1727,
                  "nodeType": "ExpressionStatement",
                  "src": "17868:37:14"
                }
              ]
            },
            "documentation": "@dev PublicRange.sol will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction throws.\n@notice See PublicRangeInterface for how method calls should be constructed.\nPublicRange.sol is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1729,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1720,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1247:2:14"
            },
            "returnParameters": {
              "id": 1721,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1259:0:14"
            },
            "scope": 1730,
            "src": "1239:16673:14",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1731,
        "src": "789:17125:14"
      }
    ],
    "src": "0:17915:14"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {
    "1567900825806": {
      "events": {},
      "links": {},
      "address": "0xA5838D29ffFbC174BC25Ca72111C81A4c0553936",
      "transactionHash": "0x2fa0a80a91aaccee85509abb87aab7bbccb59177fc83a5d3db8bed4e6560736b"
    }
  },
  "schemaVersion": "3.0.15",
  "updatedAt": "2019-09-08T01:44:16.029Z",
  "devdoc": {
    "author": "AZTEC",
    "details": "Library to validate AZTEC public range zero-knowledge proofs Don't include this as an internal library. This contract uses  a static memory table to cache elliptic curve primitives and hashes. Calling this internally from another function will lead to memory  mutation and undefined behaviour. The intended use case is to call this externally via `staticcall`. External  calls to OptimizedAZTEC can be treated as pure functions as this contract  contains no storage and makes no external calls (other than to precompiles) Copyright Spilsbury Holdings Ltd 2019. All rights reserved.*",
    "methods": {},
    "title": "PublicRange"
  },
  "userdoc": {
    "methods": {}
  }
}